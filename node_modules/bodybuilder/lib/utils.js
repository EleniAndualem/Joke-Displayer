'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmpty = undefined;
exports.sortMerge = sortMerge;
exports.buildClause = buildClause;
exports.toBool = toBool;
exports.isFunction = isFunction;
exports.has = has;
exports.pushQuery = pushQuery;
exports.isString = isString;
exports.set = set;

var _lodash = require('lodash.isplainobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isobject');

var _lodash4 = _interopRequireDefault(_lodash3);

var _queryBuilder = require('./query-builder');

var _queryBuilder2 = _interopRequireDefault(_queryBuilder);

var _filterBuilder = require('./filter-builder');

var _filterBuilder2 = _interopRequireDefault(_filterBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Compound sort function into the list of sorts
 *
 * @private
 *
 * @param  {Array} current Array of Elasticsearch sorts.
 * @param  {String} field Field to sort.
 * @param  {String|Object} value A valid direction ('asc', 'desc') or object with sort options
 * @returns {Array} Array of Elasticsearch sorts.
 */
function sortMerge(current, field, value) {
  var payload = void 0;

  if ((0, _lodash2.default)(value)) {
    payload = _defineProperty({}, field, Object.assign({}, value));
  } else {
    payload = _defineProperty({}, field, { order: value });
  }

  var idx = current.findIndex(function (o) {
    return o[field] != undefined;
  });

  if ((0, _lodash2.default)(value) || idx === -1) {
    current.push(payload);
  } else {
    Object.assign(current[idx], payload);
  }

  return current;
}

/**
 * Generic builder for query, filter, or aggregation clauses.
 *
 * @private
 *
 * @param  {string|Object} field Field name or complete clause.
 * @param  {string|Object} value Field value or inner clause.
 * @param  {Object}        opts  Additional key-value pairs.
 *
 * @return {Object} Clause
 */
function buildClause(field, value, opts) {
  var hasField = field != null;
  var hasValue = value != null;
  var mainClause = {};

  if (hasValue) {
    mainClause = _defineProperty({}, field, value);
  } else if ((0, _lodash4.default)(field)) {
    mainClause = field;
  } else if (hasField) {
    mainClause = { field: field };
  }

  return Object.assign({}, mainClause, opts);
}

function toBool(filters) {
  var unwrapped = {
    must: unwrap(filters.and),
    should: unwrap(filters.or),
    must_not: unwrap(filters.not),
    minimum_should_match: filters.minimum_should_match
  };

  if (filters.and.length === 1 && !unwrapped.should && !unwrapped.must_not) {
    return unwrapped.must;
  }

  var cleaned = {};

  if (unwrapped.must) {
    cleaned.must = unwrapped.must;
  }
  if (unwrapped.should) {
    cleaned.should = filters.or;
  }
  if (unwrapped.must_not) {
    cleaned.must_not = filters.not;
  }
  if (unwrapped.minimum_should_match && filters.or.length > 1 || filters.minimum_should_match_override) {
    cleaned.minimum_should_match = unwrapped.minimum_should_match;
  }

  return {
    bool: cleaned
  };
}

function unwrap(arr) {
  return arr.length > 1 ? arr : arr.slice(-1)[0];
}

function isFunction(func) {
  if (func && typeof func === "function") {
    return true;
  }
  return false;
}

function has(obj, key) {
  var keyParts = key.split('.');

  return !!obj && (keyParts.length > 1 ? has(obj[key.split('.')[0]], keyParts.slice(1).join('.')) : hasOwnProperty.call(obj, key));
}

function pushQuery(existing, boolKey, type) {
  var nested = {};

  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  if (isFunction(args.slice(-1)[0])) {
    var nestedCallback = args.pop();
    var nestedResult = nestedCallback(Object.assign({}, (0, _filterBuilder2.default)({ isInFilterContext: this.isInFilterContext }), this.isInFilterContext ? {} : (0, _queryBuilder2.default)({ isInFilterContext: this.isInFilterContext })));
    if (!this.isInFilterContext && nestedResult.hasQuery()) {
      nested.query = nestedResult.getQuery();
    }
    if (nestedResult.hasFilter()) {
      nested.filter = nestedResult.getFilter();
    }
  }

  if (['bool', 'constant_score'].includes(type) && this.isInFilterContext && has(nested, 'filter.bool')) {
    // nesting filters: We've introduced an unnecessary `filter.bool`
    existing[boolKey].push(_defineProperty({}, type, Object.assign(buildClause.apply(undefined, args), nested.filter.bool)));
  } else if (type === 'bool' && has(nested, 'query.bool')) {
    existing[boolKey].push(_defineProperty({}, type, Object.assign(buildClause.apply(undefined, args), nested.query.bool)));
  } else {
    // Usual case
    existing[boolKey].push(_defineProperty({}, type, Object.assign(buildClause.apply(undefined, args), nested)));
  }
}

var isEmpty = exports.isEmpty = function isEmpty(obj) {
  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;
};

function isString(str) {
  if (str && typeof str.valueOf() === "string") {
    return true;
  }
  return false;
}

/**
 * Util to replace lodash.set, sets the value of an object
 *
 * @private
 *
 * @param  {Object} obj Object to set value in
 * @param  {string|Object} path Path in the object where to set the value
 * @param  {Object} value  Value to set
 *
 * @return {Object} undefined
 */
function set(obj, path, value) {
  var keys = Array.isArray(path) ? path : path.replace(/\[/g, '.').replace(/\]/g, '').split('.'); // removes array reference and convert path to array if it's a string

  var lastKeyIndex = keys.length - 1;

  for (var i = 0; i < lastKeyIndex; i++) {
    var key = keys[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }

  obj[keys[lastKeyIndex]] = value;
}