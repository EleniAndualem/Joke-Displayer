'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = bodybuilder;

var _lodash = require('lodash.isplainobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.merge');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.clonedeep');

var _lodash6 = _interopRequireDefault(_lodash5);

var _queryBuilder = require('./query-builder');

var _queryBuilder2 = _interopRequireDefault(_queryBuilder);

var _filterBuilder = require('./filter-builder');

var _filterBuilder2 = _interopRequireDefault(_filterBuilder);

var _aggregationBuilder = require('./aggregation-builder');

var _aggregationBuilder2 = _interopRequireDefault(_aggregationBuilder);

var _suggestionBuilder = require('./suggestion-builder');

var _suggestionBuilder2 = _interopRequireDefault(_suggestionBuilder);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * **http://bodybuilder.js.org**
 *
 * **https://github.com/danpaz/bodybuilder**
 *
 * Bodybuilder is a small library that makes elasticsearch queries easier to
 * write, read, and maintain ðŸ’ª. The whole public api is documented here, but
 * how about a simple example to get started:
 *
 * ```
 * bodybuilder()
 *   .query('match', 'message', 'this is a test')
 *   .build()
 *
 * // results in:
 * {
 *   query: {
 *     match: {
 *       message: 'this is a test'
 *     }
 *   }
 * }
 * ```
 *
 * You can chain multiple methods together to build up a more complex query.
 *
 * ```
 * bodybuilder()
 *   .query('match', 'message', 'this is a test')
 *   .filter('term', 'user', 'kimchy')
 *   .notFilter('term', 'user', 'cassie')
 *   .aggregation('terms', 'user')
 *   .build()
 * ```
 *
 * For nested sub-queries or sub-aggregations, pass a function as the last
 * argument and build the nested clause in the body of that function. Note that
 * you must `return` the builder object in the nested function. For example:
 *
 * ```
 * bodybuilder()
 *   .query('nested', 'path', 'obj1', (q) => {
 *     return q.query('match', 'obj1.color', 'blue')
 *   })
 *   .build()
 * ```
 *
 *
 *
 * The entire elasticsearch query DSL is available using the bodybuilder api.
 * There are many more examples in the docs as well as in the tests.
 *
 * @param  {Object} newBody Body to initialise with
 * @param  {Object} newQueries Queries to initialise with
 * @param  {Object} newFilters Filters to initialise with
 * @param  {Object} newAggregations Aggregations to initialise with
 * @param  {Object} newSuggestions Suggestions to initialise with
 * @return {bodybuilder} Builder.
 */
function bodybuilder(newBody, newQueries, newFilters, newAggregations, newSuggestions) {
  var body = newBody || {};

  return Object.assign({
    /**
     * Set a sort direction on a given field.
     *
     * ```
     * bodybuilder()
     *   .sort('timestamp', 'desc')
     *   .build()
     * ```
     * You can sort multiple fields at once
     *
     * ```
     * bodybuilder()
     *  .sort([
     *    {"categories": "desc"},
     *    {"content": "asc"}
     *  ])
     *   .build()
     * ```
     * Geo Distance sorting is also supported & it's the only sort type that allows for duplicates
     *
     * ```
     * bodyBuilder().sort([
     *     {
     *       _geo_distance: {
     *         'a.pin.location': [-70, 40],
     *         order: 'asc',
     *         unit: 'km',
     *         mode: 'min',
     *         distance_type: 'sloppy_arc'
     *       }
     *     },
     *     {
     *       _geo_distance: {
     *         'b.pin.location': [-140, 80],
     *         order: 'asc',
     *         unit: 'km',
     *         mode: 'min',
     *         distance_type: 'sloppy_arc'
     *       }
     *     }
     *   ])
     *   .sort([
     *     { timestamp: 'desc' },
     *     { content: 'desc' },
     *     { content: 'asc' },
     *    {"price" : {"order" : "asc", "mode" : "avg"}}
     *   ])
     * .build()
     * ```
     *
     * @param  {String} field             Field name.
     * @param  {String} [direction='asc'] A valid direction: 'asc' or 'desc'.
     * @returns {bodybuilder} Builder.
     */
    sort: function sort(field) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asc';

      body.sort = body.sort || [];

      if (Array.isArray(field)) {

        if ((0, _lodash2.default)(body.sort)) {
          body.sort = [body.sort];
        }

        if (Array.isArray(body.sort)) {
          field.forEach(function (sorts) {
            if ((0, _utils.isString)(sorts)) {
              return (0, _utils.sortMerge)(body.sort, sorts, direction);
            }
            Object.entries(sorts).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  key = _ref2[0],
                  value = _ref2[1];

              (0, _utils.sortMerge)(body.sort, key, value);
            });
          });
        }
      } else {
        (0, _utils.sortMerge)(body.sort, field, direction);
      }
      return this;
    },


    /**
     * Set a *from* offset value, for paginating a query.
     *
     * @param  {Number} quantity The offset from the first result you want to
     *                           fetch.
     * @returns {bodybuilder} Builder.
     */
    from: function from(quantity) {
      body.from = quantity;
      return this;
    },


    /**
     * Set a *size* value for maximum results to return.
     *
     * @param  {Number} quantity Maximum number of results to return.
     * @returns {bodybuilder} Builder.
     */
    size: function size(quantity) {
      body.size = quantity;
      return this;
    },


    /**
     * Set any key-value on the elasticsearch body.
     *
     * @param  {String} k Key.
     * @param  {any}    v Value.
     * @returns {bodybuilder} Builder.
     */
    rawOption: function rawOption(k, v) {
      body[k] = v;
      return this;
    },


    /**
     * Collect all queries, filters, and aggregations and build the entire
     * elasticsearch query.
     *
     * @param  {string} [version] (optional) Pass `'v1'` to build for the
     *                            elasticsearch 1.x query dsl.
     *
     * @return {Object} Elasticsearch query body.
     */
    build: function build(version) {
      var queries = this.getQuery();
      var filters = this.getFilter();
      var aggregations = this.getAggregations();
      var suggestions = this.getSuggestions();

      if (version === 'v1') {
        return _buildV1(body, queries, filters, aggregations);
      }

      return _build(body, queries, filters, aggregations, suggestions);
    },


    /**
     * Returns a cloned instance of bodybuilder
     *
     * ```
     * const bodyA = bodybuilder().size(3);
     * const bodyB = bodyA.clone().from(2); // Doesn't affect bodyA
     * // bodyA: { size: 3 }
     * // bodyB: { size: 3, from: 2 }
     * ```
     *
     * @return {bodybuilder} Newly cloned bodybuilder instance
     */
    clone: function clone() {
      var queries = this.getRawQuery();
      var filters = this.getRawFilter();
      var aggregations = this.getRawAggregations();
      var suggestions = this.getSuggestions();

      return bodybuilder.apply(undefined, _toConsumableArray([body, queries, filters, aggregations, suggestions].map(function (obj) {
        return (0, _lodash6.default)(obj);
      })));
    }
  }, (0, _queryBuilder2.default)(undefined, newQueries), (0, _filterBuilder2.default)(undefined, newFilters), (0, _aggregationBuilder2.default)(newAggregations), (0, _suggestionBuilder2.default)(newSuggestions));
}

function _buildV1(body, queries, filters, aggregations) {
  var clonedBody = (0, _lodash6.default)(body);

  if (!(0, _utils.isEmpty)(filters)) {
    (0, _utils.set)(clonedBody, 'query.filtered.filter', filters);

    if (!(0, _utils.isEmpty)(queries)) {
      (0, _utils.set)(clonedBody, 'query.filtered.query', queries);
    }
  } else if (!(0, _utils.isEmpty)(queries)) {
    (0, _utils.set)(clonedBody, 'query', queries);
  }

  if (!(0, _utils.isEmpty)(aggregations)) {
    (0, _utils.set)(clonedBody, 'aggregations', aggregations);
  }
  return clonedBody;
}

function _build(body, queries, filters, aggregations, suggestions) {
  var clonedBody = (0, _lodash6.default)(body);

  if (!(0, _utils.isEmpty)(filters)) {
    var filterBody = {};
    var queryBody = {};
    (0, _utils.set)(filterBody, 'query.bool.filter', filters);
    if (!(0, _utils.isEmpty)(queries.bool)) {
      (0, _utils.set)(queryBody, 'query.bool', queries.bool);
    } else if (!(0, _utils.isEmpty)(queries)) {
      (0, _utils.set)(queryBody, 'query.bool.must', queries);
    }
    (0, _lodash4.default)(clonedBody, filterBody, queryBody);
  } else if (!(0, _utils.isEmpty)(queries)) {
    (0, _utils.set)(clonedBody, 'query', queries);
  }

  if (!(0, _utils.isEmpty)(aggregations)) {
    (0, _utils.set)(clonedBody, 'aggs', aggregations);
  }

  if (!(0, _utils.isEmpty)(suggestions)) {
    (0, _utils.set)(clonedBody, 'suggest', suggestions);
  }

  return clonedBody;
}

module.exports = bodybuilder;